// Goals: Have a crafting system that allows unordered items as ingredients and produces an item
// Challenges:
//   - The user may specify the items in any order
//   - The user may specify items that do not produce a recipe
//   - If there is a large number of recipes, we want to be able to have a quick look up.
// Proposed Solution:
//   Create a class IngredientList which can be used as a Key in a dictionary. It is created
//   from an arbitrary list of Items. The order of the items should not matter. Duplicate items
//   may be present in the list. For example, 3 wood + 1 iron = Sword or 3 iron = Shield
//
//   Challenge: IngredientLists are equal and have the same hashcode if they contain the same items in any order

Item wood = new("Wood");
Item iron = new("Iron");
Item sword = new("Sword");
Item shield = new("Shield");

IngredientList swordList0 = new IngredientList(wood, wood, iron); // Notice they have different orders
IngredientList swordList1 = new IngredientList(wood, iron, wood); 
IngredientList swordList2 = new IngredientList(iron, wood, wood);
Console.WriteLine($"swordList0.GetHashCode() => {swordList0.GetHashCode()}");  // But the hashcodes are identical
Console.WriteLine($"swordList1.GetHashCode() => {swordList1.GetHashCode()}");
Console.WriteLine($"swordList2.GetHashCode() => {swordList2.GetHashCode()}");
Console.WriteLine($"swordList0.Equals(swordList1) => {swordList0.Equals(swordList1)}"); // and they are equal to each other
Console.WriteLine($"swordList1.Equals(swordList2) => {swordList1.Equals(swordList2)}"); 
Console.WriteLine($"swordList0.Equals(swordList2) => {swordList0.Equals(swordList2)}"); 

IngredientList shieldList = new IngredientList(iron, iron, iron);
Console.WriteLine($"shieldList.GetHashCode() => {shieldList.GetHashCode()}");  // Different ingredient set produces a different hashcode
Console.WriteLine($"shieldList.Equals(swordList0) => {shieldList.Equals(swordList0)}"); // and is not equal to the other list
Console.WriteLine($"shieldList.Equals(swordList1) => {shieldList.Equals(swordList1)}"); // and is not equal to the other list
Console.WriteLine($"shieldList.Equals(swordList2) => {shieldList.Equals(swordList2)}"); // and is not equal to the other list


// We can construct a recipe database from IngredientList to Item results
Dictionary<IngredientList, Item> recipesDatabase = new ();
recipesDatabase[new IngredientList(wood, wood, iron)] = sword;
recipesDatabase[new IngredientList(iron, iron, iron)] = shield;

// And query in any order:
TryRecipe(wood, wood, wood); // No such recipe
TryRecipe(wood, iron, wood); 
TryRecipe(iron, wood, wood); 
TryRecipe(wood, wood, iron); 
TryRecipe(iron, iron, iron); 

void TryRecipe(params Item[] items)
{
    IngredientList ingredients = new (items);
    string asItemList = string.Join(",", items.Select(i => i.Name));
    if (recipesDatabase.TryGetValue(ingredients, out Item? result))
    {
        Console.WriteLine($"{asItemList} => {result.Name}");
    }
    else
    {
        Console.WriteLine($"No such recipe for ingredients: {asItemList}.");
    }
}

// A very basic Item that only has a name
class Item
{
    public string Name { get; private set; }

    public Item(string name)
    {
        this.Name = name;
    }

    // Autogenerated, if two items have the same name, they are equal
    public override bool Equals(object? obj)
    {
        return obj is Item item &&
               Name == item.Name;
    }

    // Autogenerated, uses the Name to generate a hashcode
    public override int GetHashCode()
    {
        return HashCode.Combine(Name);
    }
}

class IngredientList
{
    // The keys in this dictionary represent the items necessary
    // and the int represents the count of those items. For example,
    // you might need 3 wood and 1 iron to create a sword.
    private readonly Dictionary<Item, int> _ingredients = new();
    private int _hashcode;

    public IngredientList(IEnumerable<Item> ingredients)
    {
        // Iterates through the ingredients and counts them (no need to sort)
        foreach (Item ingredient in ingredients)
        {
            // A cheap hashcode is just the sum of the hashes of the ingredients, order won't matter here.
            // We build it up during construction so we don't have to recalculate it each time.
            _hashcode += ingredient.GetHashCode();
            if (!_ingredients.ContainsKey(ingredient))
            {
                _ingredients[ingredient] = 1;
            }
            else
            {
                _ingredients[ingredient]++;
            }
        }
    }

    public IngredientList(params Item[] ingredients) : this(ingredients.ToList()) { }

    // Check for equality. The order here is important to reduce computation time
    // when comparing ingredient lists that are not identical
    public override bool Equals(object? other)
    {
        return other is IngredientList otherList && // If it isn't an ingredientList, stop 
               _hashcode == otherList._hashcode && // If the hashcodes do not match, stop
               CompareDictionaries(otherList._ingredients); // If the hashcode matches, we still need to compare all entries JUST to make sure
    }

    // This method checks that two dictionaries contain all the same key/pair values. I would put this in
    // a DictionaryExtensions class
    public bool CompareDictionaries(Dictionary<Item, int> other)
    {
        if (_ingredients.Count != other.Count) { return false; } // Return false if the dictionaries don't have the same size
                                                                // Loop through each pair and compare them, if we find a pair that doesn't match, we return false
        foreach (KeyValuePair<Item, int> pair in other)
        {
            if (!other[pair.Key].Equals(pair.Value)) { return false; } // If ANY key pair value does not match, we stop and return false
        }
        return true; // If we make it here, everything matched
    }

    // HashCode is cached so we just return it
    public override int GetHashCode() => _hashcode;
}
